# 高级优化

### 一、提升开发体验

在开发环境下，一般使用devserver进行简化开发，但是devserver会将打包后的代码存放在内存中，所以没法在编译器中查看，所以需要借助浏览器查看，在浏览器中通过F12打开调试工具中的源代码选项卡（source），找到对应的本地域名和端口号下的打包后的资源。通过devserver中的static配置项也可以进行访问，具体请看[webpack基础篇](https://jiangwayway.github.io/2025/05/07/webpack%E5%9F%BA%E7%A1%80%E7%AF%87/)

其次，打包后 css 和 js 可能合并成了一个文件，并且多了其他代码。此时如果代码运行出错那么提示代码错误位置我们是看不懂的。一旦将来开发代码文件很多，那么很难去发现错误出现在哪里。所以我们需要更加准确的错误提示，来帮助我们更好的开发代码。

#### 1.SourceMap源代码映射

SourceMap（源代码映射）是一个用来生成源代码与构建后代码一一映射的文件的方案。

它会生成一个 xxx.map 文件，里面包含源代码和构建后代码每一行、每一列的映射关系。当构建后代码出错了，会通过 xxx.map 文件，从构建后代码出错位置找到映射后源代码出错位置，从而让浏览器提示源代码文件出错位置，帮助我们更快的找到错误根源。

具体的使用可以查看webpack文档中的devtool部分，SourceMap 的值有很多种情况。

但实际开发时我们只需要关注两种情况即可：

- 开发模式：cheap-module-source-map

  - 优点：打包编译速度快，只包含行映射
  - 缺点：没有列映射

```js
module.exports = {
  // 其他省略
  mode: "development",
  devtool: "cheap-module-source-map",
};
```

- 生产模式：source-map
  - 优点：包含行/列映射
  - 缺点：打包编译速度更慢

```js
module.exports = {
  // 其他省略
  mode: "production",
  devtool: "source-map",
};
```

### 二、提升打包构建速度

#### 1.热更新（HMR/热模块替换）

开发时我们修改了其中一个模块代码，Webpack 默认会将所有模块从入口文件开始全部重新打包编译，速度很慢。所以我们需要做到修改某个模块代码，就只有这个模块代码需要重新打包编译，其他模块不变，这样打包速度就能很快。热更新可以在程序运行中，替换、添加或删除模块，而无需重新加载整个页面。

##### （1）相关配置

```js
module.exports = {
  // ...
  devServer: {
    // 开启热模块替换，默认是true开启。
    hot: true,
  }
}
```

注意：
- 生产环境下需不需要配置热更新？不需要，生产环境下不能配置devServer，更没法配置devServer中的hot了。
- 配置热更新后，默认只有css生效，因为css-loader内置了热更新的功能，js如果想要热更新需要单独处理，以下是一些热更新不生效的情况：
  - 如果配置了mini-css-extract-plugin单独提取css文件，则css热更新不生效，一般情况下只有生产环境下才需要配置mini-css-extract-plugin插件解决闪屏现象，开发环境下不用提取css文件，所以注释掉mini-css-extract-plugin插件就可以解决了。
  - 对于html来说，我们一般会使用html-webpack-plugin插件进行处理，但是我发现如果html模板没有放在根目录下的public文件夹下（或者说没有放在devServer中的static配置的文件夹下），热更新是不会生效的，但是html好像不需要热更新，一般我们通过vue框架或者react框架生成html中的内容，很少修改html模板，所以我觉得可以不用管。
  - 我在网上发现很多人说如果没啥问题热更新还不生效，因为webpack配置中没有配置 target属性导致的，配置中添加 target:'web'就可以实现热更新了（官方文档上面说target是当前项目的构建目标。有browserslist配置则默认值为'browserslist';没有browserslist配置，则默认值为'web'）。

##### （2）如何实现js的热更新？

一般情况下，我们一般使用vue或者react框架进行开发，这些框架使用了vue-loader, react-hot-loader可以实现js的热更新。如果要自己实现js的热更新，需要在js文件中添加以下代码。

```js
// main.js
import count from "./js/count";
import sum from "./js/sum";

const result1 = count(2, 1);
console.log(result1);
const result2 = sum(1, 2, 3, 4);
console.log(result2);

// 判断是否支持HMR功能
if (module.hot) {
  //会检测count.js文件，如果count.js文件发生了改变，只会替换该文件，不会从入口开始重新打包。
  module.hot.accept("./js/count.js", function (count) {
    const result1 = count(2, 1);
    console.log(result1);
  });
  //会检测sum.js文件，如果sum.js文件发生了改变，只会替换该文件，不会从入口开始重新打包。
  module.hot.accept("./js/sum.js", function (sum) {
    const result2 = sum(1, 2, 3, 4);
    console.log(result2);
  });
}
```

#### 2.OneOf

打包时每个文件都会经过所有 test匹配，即使匹配上了某个 test 正则，后面所有的test都要过一遍。比较慢。通过OneOf配置，只要匹配上了一个，后面的就不用匹配了。

```js
module.exports = {
  module: {
    rules: [
      {
        oneOf: [
          {
            // 用来匹配 .css 结尾的文件
            test: /\.css$/,
            // use 数组里面 Loader 执行顺序是从右到左
            use: ["style-loader", "css-loader"],
          },
          {
            test: /\.less$/,
            use: ["style-loader", "css-loader", "less-loader"],
          },
          {
            test: /\.s[ac]ss$/,
            use: ["style-loader", "css-loader", "sass-loader"],
          },
          {
            test: /\.styl$/,
            use: ["style-loader", "css-loader", "stylus-loader"],
          },
          {
            test: /\.(ttf|woff2?)$/,
            type: "asset/resource",
            generator: {
              filename: "static/media/[hash:8][ext][query]",
            },
          },
          {
            test: /\.js$/,
            exclude: /node_modules/, // 排除node_modules代码不编译
            loader: "babel-loader",
          },
        ],
      },
    ],
  },
};
```

#### 3.Include/Exclude/Test
开发时我们需要使用第三方的库或插件，所有文件都下载到 node_modules 中了。而这些文件是不需要编译可以直接使用的。所以我们在使用loader或者eslint插件对 js 文件处理时，除了匹配test正则，还有要排除 node_modules 下面的文件（eslint默认排除node_modules模块）。具体配置可以看[webpack基础篇](https://jiangwayway.github.io/2025/05/07/webpack%E5%9F%BA%E7%A1%80%E7%AF%87/)。

#### 4.Eslint和Babel的Cache缓存
由于打包时大部分处理的都是js资源（大部分情况下都是对js打包进行优化），而每次打包时 js 文件都要经过 Eslint 检查 和 Babel 编译，速度比较慢。我们可以缓存之前的 Eslint 检查 和 Babel 编译结果，这样第二次打包时速度就会更快了（首次打包速度是不变的）。

```js
const path = require("path");
const ESLintWebpackPlugin = require("eslint-webpack-plugin");

module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        loader: "babel-loader",
        options: {
          cacheDirectory: true, // 开启babel编译缓存,默认缓存路径是"./node_modules/.cache/babel-loader"中
          cacheCompression: false, // 缓存文件不要压缩
        },
      },
    ],
  },
  plugins: [
    new ESLintWebpackPlugin({
      // 指定检查文件的根目录
      context: path.resolve(__dirname, "../src"),
      exclude: "node_modules", // 默认值
      cache: true, // 开启缓存
      // 缓存目录，默认缓存路径是"./node_modules/.cache/eslint-webpack-plugin/.eslintcache"中
      cacheLocation: path.resolve(
        __dirname,
        "../node_modules/.cache/.eslintcache"
      ),
    }),
  ],
};
```

#### 5.多进程打包
当项目越来越庞大时，打包速度越来越慢，甚至于需要一个下午才能打包出来代码。这个速度是比较慢的。我们想要继续提升打包速度，其实就是要提升 js 的打包速度，因为其他文件都比较少。而对 js 文件处理主要就是 eslint（检测js代码格式） 、babel（转化es6语法）、Terser（压缩js代码）三个工具，所以我们要提升它们的运行速度。我们可以开启多进程同时处理 js 文件，这样速度就比之前的单进程打包更快了。生产模式下js默认压缩就是通过Terser实现的。

**需要注意：请仅在特别耗时的操作中使用，因为每个进程启动就有大约为 600ms 左右开销**

##### （1）获取CPU核数

```js
// nodejs核心模块，直接使用
const os = require("os");
// cpu核数
const threads = os.cpus().length;
```

##### （2）下载loader

```
npm i thread-loader -D
```

##### （3）配置使用

```js
const os = require("os");

//webpack内置，直接导入使用即可
const TerserPlugin = require("terser-webpack-plugin");

// cpu核数
const threads = os.cpus().length;

module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: "thread-loader", // 1.babel转化es语法开启多进程
            options: {
              workers: threads, // 数量
            },
          },
          {
            loader: "babel-loader",
            options: {
              cacheDirectory: true,
            },
          },
        ],
      },
    ],
  },
  plugins: [
    new ESLintWebpackPlugin({
      context: path.resolve(__dirname, "../src"),
      threads, // 2.eslint检测js格式开启多进程
    }),
    // css压缩也可以写到optimization.minimizer里面，效果一样的
    new CssMinimizerPlugin(),
    //压缩js代码
    new TerserPlugin({
        parallel: threads // 3.terser压缩js代码开启多进程
      })
  ],
  mode: "production",
  devtool: "source-map",
};
```

对于压缩类型的插件现在建议放到optimization（主要配置压缩和分包）中，以后可能只能放到optimization中了，从现在开始养成良好的习惯。

```js
const os = require("os");

//webpack内置，直接导入使用即可
const TerserPlugin = require("terser-webpack-plugin");

// cpu核数
const threads = os.cpus().length;

module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: "thread-loader", // 1.babel转化es语法开启多进程
            options: {
              workers: threads, // 数量
            },
          },
          {
            loader: "babel-loader",
            options: {
              cacheDirectory: true,
            },
          },
        ],
      },
    ],
  },
  plugins: [
    new ESLintWebpackPlugin({
      context: path.resolve(__dirname, "../src"),
      threads, // 2.eslint检测js格式开启多进程
    }),

  ],
  //配置优化策略，主要包括压缩和代码分割。
  optimization: {
    minimize: true,//只有true时才会调用 minimizer 声明的压缩器数组,执行压缩操作，否则使用默认压缩工具(minimizer)。
    minimizer: [
      // Webpack5 之后，约定使用 "..." 字面量保留默认 `minimizer` 配置
      "...",
      // css压缩
      new CssMinimizerPlugin(),
      // 压缩html
      new HtmlMinimizerPlugin({
        minimizerOptions: {
          collapseBooleanAttributes: true,// 折叠 Boolean 型属性
          useShortDoctype: true,// 使用精简 `doctype` 定义
          // ...
        },
      }),
      //压缩js代码
      new TerserPlugin({
          parallel: threads // 3.terser压缩js代码开启多进程,生产模式下不用配置，默认开启。
        })
    ],
  },

  mode: "production",
  devtool: "source-map",
};
```

### 三、减少代码体积
tree shaking（使用treeshaking必须要编译成ES6，要是编译成ES6，浏览器怎么识别呢？）,sideEffect,多入口打包（公共模块单独打包，node_module单独打包，动态导入单独打包），单入口打包（node_module单独打包，动态导入单独打包）

1.treeshaking

（1）打包流程

首先使用webpack-cli合并配置参数，在启动webpack打包的时候如果指定了配置文件的路径，就会对配置文件进行读取，如果没有指定配置文件，则使用运行目录的默认配置文件，如果在命令行和配置文件中同时配置了某个配置项，则命令行配置的优先级更高，合并完配置文件之后就会创建complier对象。

从入口文件开始根据依赖关系构建依赖图。

根据依赖图使用相应的loader对模块进行处理。

treeshaking的标记和删除阶段发生这里。（因为插件可以利用webpack的生命周期钩子，在某个时期进行操作）

将打包后的资源文件合并到main.js中。

treeshaking在webpack流程中的什么时候生效,treeshaking在经过所有的loader处理后才会进行以下阶段
标记阶段（usedExports）
删除阶段（Terser）
在生产环境下，这两个默认开启，开发环境下需要同时开启这两个才能使treeshaking生效

（2）和babel-loader的冲突问题

，但是我有一个问题，treeshaking必须要es6模块才能生效，而babel-loader会把es6转化为es5，网上都说可以配置不将es6转化为es5，那es6模块浏览器可以识别运行吗？开发模式下使用webpack的目的不就是要将es6模块转化为commonjs模块吗？

这个地方有个误区，我一直以为开发模式下webpack是将es6module语法转换为commonjs语法，生产模式下则是将所有的es6语法转化为es5语法，然后在浏览器中运行的是es5语法，实际上无论es6module还是commonjs都不是在浏览器中运行时的模块化语法，webpack打包时会将es6module和commonjs语法转化为了另一种模块化语法在浏览器中运行，所以在babel-loader中配置不将es6module转化为commonjs对于打包后的结果并没有特别大的影响，注意这里指的是不将es6module转化为commonjs模块化语法，其他的es6语法为了兼容性还是需要转化为es5语法的（比如说箭头函数等等，注意es6语法和es6模块化的区别，es6语法包含es6模块化）

（3）打包后内容分析
webpack 打包输出打是一个 IIFE（立即执行的匿名函数）

注意：当想要看webpack打包之后的内容时，将设置`mode: 'none'`,这样打包的时候不会使用webpack内置的插件对打包后的代码进行处理，可以更直观的看到打包后的结果。

（4）作用域提升
只引用一次的模块才会生效

2.sideEffects副作用
什么是副作用
如何消除副作用

3.合并配置代码

4.图片压缩


### 四、优化代码运行性能



